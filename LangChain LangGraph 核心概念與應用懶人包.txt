# 檔名：LangChain LangGraph 核心概念與應用懶人包

**一言以蔽之**：LangGraph 是 LangChain 的延伸，讓開發者能更輕鬆、更彈性地建構和執行複雜的、具備迴圈（Cycles）的代理人（Agent）及其運行環境。

**關鍵重點**：

*   LangGraph 建立在 LangChain 的基礎上，專注於簡化代理人（Agent）和代理人運行時間（Agent Runtime）的創建。
*   代理人被定義為由語言模型驅動、能決定執行哪些動作的系統。
*   代理人運行時間則負責在迴圈中不斷執行代理人，直到代理人認為任務完成。
*   LangGraph 的核心創新在於允許創建具備「迴圈」功能的代理人運行時間，這對於處理複雜任務至關重要，而傳統的 DAG（有向無環圖）框架則不支援此類迴圈。
*   LangGraph 引入了兩種主要的代理人運行時間：標準的 `AgentExecutor`（類似 LangChain 中的）和新的 `Chat Agent Executor`，後者特別適合處理現代基於訊息的語言模型。

**詳細摘要**：

LangGraph 是 LangChain 在代理人（Agent）和代理人運行時間（Agent Runtime）開發領域的一項重要更新，其主要目標是讓建構和執行代理人變得更加容易和靈活。

首先，我們需要理解 LangChain 中的「代理人」和「代理人運行時間」是什麼。代理人是一個由大型語言模型（LLM）驅動的系統，它能夠自行判斷並決定需要採取哪些行動來達成目標。而代理人運行時間，則是一個持續執行的迴圈，它會不斷地：

1.  接收代理人的決策（該採取什麼行動）。
2.  執行該行動。
3.  將行動的結果（觀察）回饋給代理人。
4.  代理人根據新的觀察，再次決定下一步行動，直到代理人認為任務已完成。

LangGraph 在此基礎上，進一步簡化了自訂代理人的過程。過去，LangChain 中創建代理人運行時間的方式相對固定，通常是透過一個固定的 `AgentExecutor` 類別來實現。然而，LangGraph 讓這種方式變得更加動態和多樣化。

LangGraph 的一大亮點是它能夠實現**代理人運行時間中的「迴圈」（Cycles）**。這意味著代理人可以在執行過程中不斷重複某些步驟，直到滿足特定條件。這對於處理需要多個迭代步驟、或在不同狀態之間切換的複雜任務至關重要。許多現有的框架（如 DAG 框架）僅支援有向無環圖，無法處理這種迴圈邏輯。

為了支援這種靈活性，LangGraph 引入了兩種主要的代理人運行時間：

1.  **標準的 `AgentExecutor`**：這是對 LangChain 中現有 `AgentExecutor` 的重新實現，使用 LangGraph 的框架來建構。它在功能上與舊版類似，但能更好地與 LangGraph 的其他組件整合。
2.  **`Chat Agent Executor`**：這是一個全新的運行時間，專為處理現代的「聊天式」語言模型而設計。這類模型通常將訊息歷史作為輸入，並將函數呼叫（Function Calls）或回應作為輸出。`Chat Agent Executor` 將代理人的狀態（Agent State）表示為一個訊息列表，並能直接處理這類訊息交換，非常適合用於需要對話式互動的代理人。

開發者可以透過 LangGraph 的工具，更輕鬆地修改和自訂代理人運行時間的行為，例如：

*   在執行過程中加入人工介入（Human in the loop）。
*   強制代理人優先使用特定工具。
*   實現更複雜的條件判斷和流程控制。

總之，LangGraph 讓代理人開發者能夠擺脫傳統框架的限制，更自由、更強大地建構能夠處理複雜、迭代性任務的智慧代理人。